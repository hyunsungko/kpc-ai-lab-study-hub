import React, { createContext, useContext, useEffect, useState, useRef, useCallback } from 'react';
import { supabase, getCurrentUser } from '../lib/supabase';

const AuthContext = createContext({});

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

// ÏÑ∏ÏÖò Ïä§ÌÜ†Î¶¨ÏßÄ ÌÇ§
const SESSION_KEY = 'kpc-auth-session';
const PROFILE_KEY = 'kpc-auth-profile';

// ÏµúÏ†ÅÌôîÎêú Ïù∏Ï¶ù ÏÉÅÌÉú
const AUTH_STATUS = {
  LOADING: 'loading',
  AUTHENTICATED: 'authenticated',
  UNAUTHENTICATED: 'unauthenticated'
};

export const AuthProvider = ({ children }) => {
  const [status, setStatus] = useState(AUTH_STATUS.LOADING);
  const [user, setUser] = useState(null);
  const [profile, setProfile] = useState(null);
  const [error, setError] = useState(null);
  
  // Ï†úÏñ¥ ÌîåÎûòÍ∑∏Îì§
  const mountedRef = useRef(true);
  const initializedRef = useRef(false);
  const authListenerRef = useRef(null);

  // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
  const isLoading = status === AUTH_STATUS.LOADING;
  const isAuthenticated = status === AUTH_STATUS.AUTHENTICATED;

  // ÏïàÏ†ÑÌïú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  const safeUpdate = useCallback((updater) => {
    if (mountedRef.current) {
      updater();
    }
  }, []);

  // ÏÑ∏ÏÖò Ï†ÄÏû•ÏÜå Í¥ÄÎ¶¨
  const saveToStorage = useCallback((key, data) => {
    try {
      if (data) {
        sessionStorage.setItem(key, JSON.stringify(data));
      } else {
        sessionStorage.removeItem(key);
      }
    } catch (err) {
      console.warn('Storage save failed:', err);
    }
  }, []);

  const getFromStorage = useCallback((key) => {
    try {
      const data = sessionStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    } catch (err) {
      console.warn('Storage read failed:', err);
      return null;
    }
  }, []);

  // Í∏∞Î≥∏ ÌîÑÎ°úÌïÑ ÏÉùÏÑ±
  const createDefaultProfile = useCallback((userData) => ({
    id: userData.id,
    email: userData.email,
    name: userData.email?.split('@')[0] || 'ÏÇ¨Ïö©Ïûê',
    department: 'KPC AI Lab',
    position: 'ÌåÄÏõê',
    avatar_url: null,
    bio: null,
    interests: []
  }), []);

  // ÌîÑÎ°úÌïÑ Î°úÎìú (Î∞±Í∑∏ÎùºÏö¥Îìú, Ïã§Ìå® Î¨¥Ïãú)
  const loadProfile = useCallback(async (userId) => {
    try {
      console.log('üë§ Loading profile:', userId);
      
      // Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Ï∫êÏãúÎêú ÌîÑÎ°úÌïÑ Î®ºÏ†Ä Ï≤¥ÌÅ¨
      const cached = getFromStorage(PROFILE_KEY);
      if (cached && cached.id === userId) {
        console.log('üì¶ Using cached profile');
        return cached;
      }

      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single();

      if (error && error.code === 'PGRST116') {
        // ÌîÑÎ°úÌïÑ ÏóÜÏùå - Í∏∞Î≥∏Í∞í ÏÉùÏÑ± Î∞è Ï†ÄÏû• ÏãúÎèÑ
        const userInfo = user || await getCurrentUser().then(res => res.user);
        const defaultProfile = createDefaultProfile({ id: userId, email: userInfo?.email });
        
        try {
          const { data: newProfile } = await supabase
            .from('profiles')
            .insert(defaultProfile)
            .select()
            .single();
          
          if (newProfile) {
            saveToStorage(PROFILE_KEY, newProfile);
            return newProfile;
          }
        } catch (createError) {
          console.warn('Profile creation failed, using default:', createError);
        }
        
        return defaultProfile;
      } else if (error) {
        console.error('Profile query error:', error);
        const userInfo = user || await getCurrentUser().then(res => res.user).catch(() => null);
        return createDefaultProfile({ id: userId, email: userInfo?.email });
      }

      // ÏÑ±Í≥µÌïú ÌîÑÎ°úÌïÑ Ï∫êÏãú
      saveToStorage(PROFILE_KEY, data);
      return data;
    } catch (err) {
      console.error('Profile load exception:', err);
      const userInfo = user || await getCurrentUser().then(res => res.user).catch(() => null);
      return createDefaultProfile({ id: userId, email: userInfo?.email });
    }
  }, [user, createDefaultProfile, getFromStorage, saveToStorage]);

  // ÌïµÏã¨ Ïù∏Ï¶ù Ï¥àÍ∏∞Ìôî - Îã®ÏàúÌïòÍ≥† Îπ†Î•¥Í≤å
  const initializeAuth = useCallback(async () => {
    if (initializedRef.current) return;
    initializedRef.current = true;

    try {
      console.log('üöÄ Quick auth initialization...');

      // 1. Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú ÏÑ∏ÏÖò Ï≤¥ÌÅ¨ (Ï¶âÏãú)
      const cachedSession = getFromStorage(SESSION_KEY);
      const cachedProfile = getFromStorage(PROFILE_KEY);

      // 2. Supabase ÏÑ∏ÏÖò Ï≤¥ÌÅ¨ (Î≥ëÎ†¨)
      const sessionPromise = supabase.auth.getSession();
      
      // Ï∫êÏãúÍ∞Ä ÏûàÏúºÎ©¥ Ï¶âÏãú UI ÌëúÏãú
      if (cachedSession && cachedProfile) {
        console.log('‚ö° Using cached session for instant UI');
        safeUpdate(() => {
          setUser(cachedSession);
          setProfile(cachedProfile);
          setStatus(AUTH_STATUS.AUTHENTICATED);
        });
      }

      // Ïã§Ï†ú ÏÑ∏ÏÖò Í≤ÄÏ¶ù
      const { data: { session }, error } = await sessionPromise;

      if (error) {
        console.error('Session check error:', error);
        throw error;
      }

      if (!session?.user) {
        console.log('No active session');
        // Ï∫êÏãú ÌÅ¥Î¶¨Ïñ¥
        saveToStorage(SESSION_KEY, null);
        saveToStorage(PROFILE_KEY, null);
        
        safeUpdate(() => {
          setUser(null);
          setProfile(null);
          setStatus(AUTH_STATUS.UNAUTHENTICATED);
        });
        return;
      }

      // ÏÑ∏ÏÖò Ïú†Ìö® - ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
      console.log('‚úÖ Valid session:', session.user.email);
      saveToStorage(SESSION_KEY, session.user);
      
      safeUpdate(() => {
        setUser(session.user);
        setStatus(AUTH_STATUS.AUTHENTICATED);
        
        // Ï∫êÏãúÎêú ÌîÑÎ°úÌïÑÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞íÏúºÎ°ú Ï¶âÏãú ÏÑ§Ï†ï
        if (cachedProfile && cachedProfile.id === session.user.id) {
          setProfile(cachedProfile);
        } else {
          setProfile(createDefaultProfile(session.user));
        }
      });

      // Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú ÌîÑÎ°úÌïÑ Î°úÎìú (Ïã§Ìå®Ìï¥ÎèÑ Í∏∞Î≥∏ ÌîÑÎ°úÌïÑÎ°ú ÏßÑÌñâ)
      if (!cachedProfile || cachedProfile.id !== session.user.id) {
        loadProfile(session.user.id)
          .then(userProfile => {
            safeUpdate(() => setProfile(userProfile));
          })
          .catch(err => {
            console.warn('Profile load failed, keeping default:', err);
            // Í∏∞Î≥∏ ÌîÑÎ°úÌïÑ Ïú†ÏßÄ, Ïù∏Ï¶ù ÏÉÅÌÉúÎäî Í∑∏ÎåÄÎ°ú
          });
      }

    } catch (err) {
      console.error('Auth initialization failed:', err);
      
      // Ïò§Î•ò Ïãú Î°úÍ∑∏Ïù∏ ÌôîÎ©¥
      saveToStorage(SESSION_KEY, null);
      saveToStorage(PROFILE_KEY, null);
      
      safeUpdate(() => {
        setUser(null);
        setProfile(null);
        setStatus(AUTH_STATUS.UNAUTHENTICATED);
        setError(err.message);
      });
    }
  }, [getFromStorage, saveToStorage, safeUpdate, createDefaultProfile, loadProfile]);

  // Auth ÏÉÅÌÉú Î≥ÄÌôî Î¶¨Ïä§ÎÑà (Îã§Ï§ë ÏÑ∏ÏÖò ÏßÄÏõê)
  const setupAuthListener = useCallback(() => {
    if (authListenerRef.current) return;

    console.log('üéß Setting up auth listener');
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        if (!mountedRef.current) return;

        console.log('üîÑ Auth event:', event, session?.user?.email || 'no-session');

        // Î°úÏª¨ Î°úÍ∑∏ÏïÑÏõÉÎßå Ï≤òÎ¶¨ (Îã§Î•∏ ÎîîÎ∞îÏù¥Ïä§ÏóêÏÑúÏùò Î°úÍ∑∏ÏïÑÏõÉÏùÄ Î¨¥Ïãú)
        if (event === 'SIGNED_OUT') {
          console.log('üëã Local sign out detected');
          
          // ÌòÑÏû¨ Î∏åÎùºÏö∞Ï†Ä/ÌÉ≠ÏóêÏÑúÎßå Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨
          saveToStorage(SESSION_KEY, null);
          saveToStorage(PROFILE_KEY, null);
          
          safeUpdate(() => {
            setUser(null);
            setProfile(null);
            setStatus(AUTH_STATUS.UNAUTHENTICATED);
          });
          return;
        }

        // Î°úÍ∑∏Ïù∏ Ïù¥Î≤§Ìä∏ - Ï¶âÏãú Ïù∏Ï¶ù ÏÉÅÌÉúÎ°ú Ï†ÑÌôò
        if (event === 'SIGNED_IN' && session?.user) {
          console.log('üîë User signed in:', session.user.email);
          
          saveToStorage(SESSION_KEY, session.user);
          
          safeUpdate(() => {
            setUser(session.user);
            setStatus(AUTH_STATUS.AUTHENTICATED);
            // Í∏∞Î≥∏ ÌîÑÎ°úÌïÑÎ°ú Ï¶âÏãú ÏÑ§Ï†ï (Î°úÎî© ÏÉÅÌÉú Ìï¥Ï†ú)
            setProfile(createDefaultProfile(session.user));
          });

          // Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ïã§Ï†ú ÌîÑÎ°úÌïÑ Î°úÎìú
          loadProfile(session.user.id).then(userProfile => {
            safeUpdate(() => setProfile(userProfile));
          }).catch(err => {
            console.warn('Profile load failed, using default:', err);
          });
          return;
        }

        // ÌÜ†ÌÅ∞ Í∞±Ïã†Îßå Ï≤òÎ¶¨
        if (event === 'TOKEN_REFRESHED' && session?.user) {
          console.log('üîÑ Token refreshed for:', session.user.email);
          
          const currentUser = getFromStorage(SESSION_KEY);
          if (currentUser && currentUser.id === session.user.id) {
            saveToStorage(SESSION_KEY, session.user);
            safeUpdate(() => {
              setUser(session.user);
            });
          }
        }
      }
    );

    authListenerRef.current = subscription;
    return subscription;
  }, [saveToStorage, safeUpdate, profile, loadProfile, getFromStorage]);

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏
  useEffect(() => {
    console.log('üé¨ AuthProvider mounting');
    
    // Ï¶âÏãú Ï¥àÍ∏∞Ìôî
    initializeAuth();
    
    // Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
    const subscription = setupAuthListener();
    
    // 5Ï¥à ÏïàÏ†Ñ ÌÉÄÏûÑÏïÑÏõÉ (Îçî ÏßßÍ≤å)
    const timeout = setTimeout(() => {
      if (mountedRef.current && status === AUTH_STATUS.LOADING) {
        console.log('‚è∞ Initialization timeout - showing login');
        safeUpdate(() => {
          setStatus(AUTH_STATUS.UNAUTHENTICATED);
        });
      }
    }, 5000);

    return () => {
      console.log('üëã AuthProvider unmounting');
      mountedRef.current = false;
      clearTimeout(timeout);
      if (authListenerRef.current) {
        authListenerRef.current.unsubscribe();
        authListenerRef.current = null;
      }
    };
  }, []); // Îπà ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥

  // Î°úÍ∑∏Ïù∏
  const signIn = useCallback(async (email, password) => {
    try {
      setError(null);
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      
      if (error) throw error;
      return { data, error: null };
    } catch (error) {
      setError(error.message);
      return { data: null, error };
    }
  }, []);

  // Î°úÍ∑∏ÏïÑÏõÉ
  const signOut = useCallback(async () => {
    try {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
      return { error: null };
    } catch (error) {
      return { error };
    }
  }, []);

  // ÌöåÏõêÍ∞ÄÏûÖ
  const signUp = useCallback(async (email, password, userData) => {
    try {
      setError(null);
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
      });
      
      if (error) throw error;
      return { data, error: null };
    } catch (error) {
      setError(error.message);
      return { data: null, error };
    }
  }, []);

  // ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏
  const updateProfile = useCallback(async (updates) => {
    try {
      if (!user) throw new Error('ÏÇ¨Ïö©ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
      
      const { data, error } = await supabase
        .from('profiles')
        .update(updates)
        .eq('id', user.id)
        .select()
        .single();
      
      if (error) throw error;
      
      // Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
      saveToStorage(PROFILE_KEY, data);
      setProfile(data);
      return { data, error: null };
    } catch (error) {
      return { data: null, error };
    }
  }, [user, saveToStorage]);

  const value = {
    // ÏÉÅÌÉú
    user,
    profile,
    loading: isLoading,
    isAuthenticated,
    error,
    status,
    
    // Ìï®Ïàò
    signIn,
    signOut,
    signUp,
    updateProfile,
    
    // Î†àÍ±∞Ïãú Ìò∏Ìôò
    isKPCMember: !!profile
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};